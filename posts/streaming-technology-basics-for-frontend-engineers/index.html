<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><meta name="description" content="Software engineer at CyberAgent."><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>フロントエンドエンジニアのための動画ストリーミング技術基礎 | ygoto3.com</title><meta name="description" content="AbemaTV という動画サービスをリリースしてから半年経ち、新しくサービスのフロントエンドに関わる人数が少し増えてきたため、動画に関して社内で勉強会を行いました。本記事はその勉強会資料です。 Web でメディアを見るためにはデータのダウンロードが必要  Web サービスが HTML を介して提供するコンテンツはテキスト、画像、音声、動画などいろいろありますが、テキスト以外のデータは HTML に">
<meta name="keywords" content="HLS MPEG-DASH MSE video">
<meta property="og:type" content="article">
<meta property="og:title" content="フロントエンドエンジニアのための動画ストリーミング技術基礎">
<meta property="og:url" content="https://ygoto3.com/posts/streaming-technology-basics-for-frontend-engineers/index.html">
<meta property="og:site_name" content="ygoto3.com">
<meta property="og:description" content="AbemaTV という動画サービスをリリースしてから半年経ち、新しくサービスのフロントエンドに関わる人数が少し増えてきたため、動画に関して社内で勉強会を行いました。本記事はその勉強会資料です。 Web でメディアを見るためにはデータのダウンロードが必要  Web サービスが HTML を介して提供するコンテンツはテキスト、画像、音声、動画などいろいろありますが、テキスト以外のデータは HTML に">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/hls.png">
<meta property="og:image" content="https://placekitten.com/g/300/300">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/video-dl.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/seek.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/hls.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/m3u8-ts.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/hls-playing.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/mpd.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/containers-codecs.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/ts-packet.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/huffman.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/xsky_00001.jpg">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/DCT.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/y-cr-cb.png">
<meta property="og:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/ipb-pictures.png">
<meta property="og:updated_time" content="2019-02-13T03:11:50.332Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="フロントエンドエンジニアのための動画ストリーミング技術基礎">
<meta name="twitter:description" content="AbemaTV という動画サービスをリリースしてから半年経ち、新しくサービスのフロントエンドに関わる人数が少し増えてきたため、動画に関して社内で勉強会を行いました。本記事はその勉強会資料です。 Web でメディアを見るためにはデータのダウンロードが必要  Web サービスが HTML を介して提供するコンテンツはテキスト、画像、音声、動画などいろいろありますが、テキスト以外のデータは HTML に">
<meta name="twitter:image" content="https://ygoto3.com/images/streaming-technology-basics-for-frontend-engineers/hls.png">
<meta name="twitter:creator" content="@ygoto3_">
<meta property="fb:app_id" content="777030512429159"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.css"><link rel="stylesheet" href="/css/index.css"></head><body class="container"><div id="fb-root"></div><script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5&appId=777030512429159";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script><div class="container-introduction"><a href="/"><h1 class="site-title">ygoto3.com</h1></a></div><div class="container-posts"><article class="post"><header><h1 class="post__title">フロントエンドエンジニアのための動画ストリーミング技術基礎</h1></header><div class="post__date">September 29, 2016</div><div class="post__entry"><p><a href="https://abema.tv/" target="_blank" rel="external">AbemaTV</a> という動画サービスをリリースしてから半年経ち、新しくサービスのフロントエンドに関わる人数が少し増えてきたため、動画に関して社内で勉強会を行いました。本記事はその勉強会資料です。</p>
<h2>Web でメディアを見るためにはデータのダウンロードが必要</h2>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/hls.png" alt="Download via HTTP"></p>
<p>Web サービスが HTML を介して提供するコンテンツはテキスト、画像、音声、動画などいろいろありますが、テキスト以外のデータは HTML にインラインで返したりせず、基本的には外部ファイルとして非同期に取得されることがほとんどだと思います。</p>
<h3>画像の場合</h3>
<p>HTML 内の <code>img</code> 要素の <code>src</code> 属性に表示したい画像ファイルのパスを指定することで、Web ブラウザはその画像をリクエストし、ダウンロードしたデータをデコードして画像として表示します。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"sample.jpg"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p><img src="https://placekitten.com/g/300/300" alt="https://placekitten.com/g/300/300"></p>
<h3>動画の場合</h3>
<p>動画の場合も同じです。<code>video</code> 要素を使って <code>img</code> 要素と同様に <code>src</code> 属性に動画ファイルのパスを指定します。</p>
<p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"sample.mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3>動画はデータ容量が大きい</h3>
<p>画像と違い、動画コンテンツはデータ容量がとても大きいため、データをダウンロードして再生するまでに待ち時間が発生します。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/video-dl.png" alt="動画のダウンロード"></p>
<p>動画のデータ容量が大きい理由はとても単純で、動画は画像データが集合したものだからです。静止画像を人間の目が滑らかに感じられる速さで切り替えて表示することで絵を動かすという表現を実現しています（よくパラパラマンガに例えられますが、そんな感じです）。この人間の目が滑らかに感じる速さというのが 1 秒間に 30 枚だったり 24 枚を切り替えることになります。29.97 (≒30) fps とか 24 fps とかの数字を耳にしたことがあるかと思いますが、24 fps の場合は 1 秒間（s）の間（p）に 24 フレーム（f）を切り替えることを意味します。</p>
<p>データを全て自分の端末にダウンロードしてから再生しようとすると、かなり長い待ち時間が発生してしまいます。もし 2 時間の映画を見ようと思ったら 172,800 (= 24 フレーム * 60 秒 * 60 分 * 2 時間) 枚の画像をダウンロードするのを待つことになります。しかも動画を構成する要素は画像だけではなく、音声データも含まれるため、純粋な情報量としてはそれ以上になります。</p>
<h2>ストリーミング</h2>
<p>動画データを全てダウンロードしてから再生するのではなく、ダウンロードしたデータで再生できる部分から再生を始め、同時に残りのデータをダウンロードしていく方式を、ストリーミング再生といいます。長時間の動画でもダウンロードしながら再生することができるので、再生するまでの待ち時間を短かくすることができます。</p>
<p>また、ストリーミングでは動画を途中から再生することも可能にします。2 時間映画のたとえば 1 時間経ったあたりから見たいとき、1 時間経過した部分からデータをダウンロードし始め、再生を始めることができます。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/seek.png" alt="シーク"></p>
<h2>AbemaTV で使用しているストリーミングプロトコル</h2>
<p>ストリーミング再生は、映像を配信する側と映像を再生する側で、データをどのような手順で通信するかをあらかじめ決めて、その手順通りに両者がデータを処理することによって実現します。その通信手順のことをストリーミングプロトコルと呼びます。ここでは AbemaTV で使用しているはストリーミングプロトコルを 2 つ説明します。</p>
<h3>HTTP Live Streaming</h3>
<p>HTTP Live Streaming はアップル社が自社プロダクトである QuickTime、OS X、iOS、Safari 向けに開発したストリーミングプロトコルです。略して HLS と呼ばれるので、この記事でも HLS と表記します。その名前の通り、通信は HTTP で行われます。専用のプロトコルが必要ないため、通常の Web サーバーを用意するだけで配信ができてしまいます。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/hls.png" alt="HLS"></p>
<p>HLS を配信するために必要なファイルは、動画を数秒ごとの「MPEG-2 TS」形式のファイルに分割したセグメントファイル、それらをどの順番で再生するかを記したプレイリストだけです。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/m3u8-ts.png" alt="m3u8 ファイルと ts ファイル"></p>
<h4>簡単な HLS の配信を試してみる</h4>
<p>まず、プレイリストとセグメントファイルを作成します。ここでは ffmpeg というツールを使い、 <code>input.mp4</code> というファイル名で保存されている動画から <code>output.m3u8</code> というプレイリストと分割されたセグメントファイルを作成します。</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ffmpeg -i input.mp4 \</div><div class="line">  -vcodec libx264 \</div><div class="line">  -s 1280x720 \</div><div class="line">  -acodec aac -b:a 256k\</div><div class="line">  -flags +loop-global_header \</div><div class="line">  -bsf h264_mp4toannexb \</div><div class="line">  -f segment -segment_format mpegts \</div><div class="line">  -segment_time 10 \</div><div class="line">  -segment_list output.m3u8 output_%04d.ts</div></pre></td></tr></table></figure></p>
<p>すると、 <code>output.m3u8</code> と <code>output_****.ts</code> というファイルが作成されます。 <code>output.m3u8</code> の内容は下記のようになります。</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#EXTM3U</div><div class="line"><span class="selector-id">#EXT-X-VERSION</span>:<span class="number">3</span></div><div class="line"><span class="selector-id">#EXT-X-MEDIA-SEQUENCE</span>:<span class="number">0</span></div><div class="line"><span class="selector-id">#EXT-X-ALLOW-CACHE</span>:YES</div><div class="line"><span class="selector-id">#EXT-X-TARGETDURATION</span>:<span class="number">18</span></div><div class="line"><span class="selector-id">#EXTINF</span>:<span class="number">10.500000</span>,</div><div class="line">output_0000.ts</div><div class="line"><span class="selector-id">#EXTINF</span>:<span class="number">12.625000</span>,</div><div class="line">output_0001.ts</div><div class="line"><span class="selector-id">#EXTINF</span>:<span class="number">10.416667</span>,</div><div class="line">output_0002.ts</div><div class="line"><span class="selector-id">#EXTINF</span>:<span class="number">10.416667</span>,</div><div class="line">output_0003.ts</div><div class="line">...略</div><div class="line">output_0058.ts</div><div class="line"><span class="selector-id">#EXTINF</span>:<span class="number">5.125000</span>,</div><div class="line">output_0059.ts</div><div class="line">#EXT-X-ENDLIST</div></pre></td></tr></table></figure></p>
<p>Web サーバーを起動します。ここでは Mac OS X にプリインストールされている Python2 を使用します。</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python -m SimpleHTTPServer</div></pre></td></tr></table></figure></p>
<p>Python2 の SimpleHTTPServer モジュールはデフォルトで <code>8000</code> 番ポートを使用するので、Safari で <a href="http://localhost:8000/output.m3u8" target="_blank" rel="external">http://localhost:8000/output.m3u8</a> にアクセスします。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/hls-playing.png" alt="Safari で HLS を再生"></p>
<p>ここでアクセスする Web ブラウザに Safari を指定しているのは、Safari 以外のメジャーブラウザでは HLS をネイティブサポートしていないためです。Safari 以外のブラウザで HLS を再生するには、Flash などのプラグインを使用するか、後述する Media Source API を使用して、JavaScript で追加実装する必要があります。HLS はアップル社が開発したということもあり、Safari だけは m3u8 をロードしてそのまま再生することができます。</p>
<h3>MPEG-DASH</h3>
<p>MPEG-DASH は HLS と同様に通信に HTTP を使用したストリーミングプロトコルです。DASH は Dynamic Adaptive Streaming over HTTP の略です。Apple 社が開発した HLS のほかに Microsoft 社が開発した Smooth Streaming や Adobe が開発した HTTP Dynamic Streaming など HTTP ベースのストリーミングプロトコルがいくつかありますが、残念ながら各々互換性がありません。MPEG-DASH は ISO 国際標準規格 (ISO/IEC 23001-6) としてリリースされています。</p>
<p>MPEG-DASH も HLS 同様、通常の Web サーバーと動画のセグメントファイルとプレイリストを用意するだけで配信ができてしまいます。MPEG-DASH ではセグメントファイルは fragmented mp4 もしくは ts 形式、プレイリストは MPD（Media Presentation Description）と呼ばれる XML で記述されたファイルを用意します。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/mpd.png" alt="MPD"></p>
<h4>簡単な MPEG-DASH の配信を試してみる</h4>
<p>MPEG-DASH 用のセグメントファイルとプレイリストを用意します。今回はセグメントファイルは fragmented mp4 を使用することにします。まず、ffmpeg を使って動画を fragmented mp4 で映像の圧縮に使う「H.264/AVC」と音声の圧縮に使う「AAC」というコーデックでリエンコードします。コーデックについては後述します。</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ffmpeg -i ./input.mp4 \</div><div class="line">  -vcodec libx264 \</div><div class="line">  -vb 500k \</div><div class="line">  -r 30 \</div><div class="line">  -x264opts no-scenecut \</div><div class="line">  -g 15 \</div><div class="line">  -acodec aac \</div><div class="line">  -ac 2 \</div><div class="line">  -ab 128k \</div><div class="line">  -frag_duration 5000000 \</div><div class="line">  -movflags frag_keyframe+empty_moov \</div><div class="line">  ./encoded.mp4</div></pre></td></tr></table></figure></p>
<p>次に MP4Box というツールを使って、動画を分割してセグメントファイルとプレイリストを作成します。</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ MP4Box -frag 4000 \</div><div class="line">  -dash 4000 \</div><div class="line">  -rap \</div><div class="line">  -segment-name sample \</div><div class="line">  -out ./output.mp4 \</div><div class="line">  ./encoded.mp4</div></pre></td></tr></table></figure></p>
<p>プレイリスト <code>output.mpd</code> と <code>output.m4s</code> と連番になったセグメントファイル郡が作成されます。 <code>output.mpd</code> は下のようになっています。</p>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="comment">&lt;!-- MPD file Generated with GPAC version 0.6.1-revrelease  at 2016-09-29T12:57:43.136Z--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MPD</span> <span class="attr">xmlns</span>=<span class="string">"urn:mpeg:dash:schema:mpd:2011"</span> <span class="attr">minBufferTime</span>=<span class="string">"PT1.500S"</span> <span class="attr">type</span>=<span class="string">"static"</span> <span class="attr">mediaPresentationDuration</span>=<span class="string">"PT0H9M56.466S"</span> <span class="attr">maxSegmentDuration</span>=<span class="string">"PT0H0M4.000S"</span> <span class="attr">profiles</span>=<span class="string">"urn:mpeg:dash:profile:full:2011"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">ProgramInformation</span> <span class="attr">moreInformationURL</span>=<span class="string">"http://gpac.sourceforge.net"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Title</span>&gt;</span>./output.mpd generated by GPAC<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">ProgramInformation</span>&gt;</span></div><div class="line"></div><div class="line"> <span class="tag">&lt;<span class="name">Period</span> <span class="attr">duration</span>=<span class="string">"PT0H9M56.466S"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">AdaptationSet</span> <span class="attr">segmentAlignment</span>=<span class="string">"true"</span> <span class="attr">maxWidth</span>=<span class="string">"320"</span> <span class="attr">maxHeight</span>=<span class="string">"180"</span> <span class="attr">maxFrameRate</span>=<span class="string">"30"</span> <span class="attr">par</span>=<span class="string">"16:9"</span> <span class="attr">lang</span>=<span class="string">"und"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">ContentComponent</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">contentType</span>=<span class="string">"video"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">ContentComponent</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">contentType</span>=<span class="string">"audio"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">Representation</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">mimeType</span>=<span class="string">"video/mp4"</span> <span class="attr">codecs</span>=<span class="string">"avc3.640014,mp4a.40.2"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"180"</span> <span class="attr">frameRate</span>=<span class="string">"30"</span> <span class="attr">sar</span>=<span class="string">"1:1"</span> <span class="attr">audioSamplingRate</span>=<span class="string">"48000"</span> <span class="attr">startWithSAP</span>=<span class="string">"1"</span> <span class="attr">bandwidth</span>=<span class="string">"631708"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">AudioChannelConfiguration</span> <span class="attr">schemeIdUri</span>=<span class="string">"urn:mpeg:dash:23003:3:audio_channel_configuration:2011"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">SegmentList</span> <span class="attr">timescale</span>=<span class="string">"1000"</span> <span class="attr">duration</span>=<span class="string">"4000"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">Initialization</span> <span class="attr">sourceURL</span>=<span class="string">"outputinit.mp4"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">SegmentURL</span> <span class="attr">media</span>=<span class="string">"output1.m4s"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">SegmentURL</span> <span class="attr">media</span>=<span class="string">"output2.m4s"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">SegmentURL</span> <span class="attr">media</span>=<span class="string">"output3.m4s"</span>/&gt;</span></div><div class="line">     ...略</div><div class="line">     <span class="tag">&lt;<span class="name">SegmentURL</span> <span class="attr">media</span>=<span class="string">"output149.m4s"</span>/&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">SegmentURL</span> <span class="attr">media</span>=<span class="string">"output150.m4s"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">SegmentList</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">Representation</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">AdaptationSet</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">Period</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">MPD</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>再び Web サーバーを起動します。</p>
<p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python -m SimpleHTTPServer</div></pre></td></tr></table></figure></p>
<p>HLS とは違い、残念ながら MPEG-DASH をネイティブでサポートしている Web ブラウザはありません。後程 Media Source Extensions を説明するときに MPEG-DASH プレイヤーを作成するので、そこで確認したいと思います。</p>
<h2>HTML5 で扱うストリーミング</h2>
<p>HLS と MPEG-DASH は HTML5 用の JavaScript API である Media Source Extensions を利用することで追加でプラグインをインストールすることなく、ストリーミング再生が可能です。</p>
<h3>Media Source Extensions</h3>
<p>Media Source Extensions は MSE と呼ばれていますので、本記事でも MSE と表記します。MSE は W3C によって標準化されている HTTP ダウンロードを利用してストリーミング再生するために作られた JavaScript API です。</p>
<p>MSE で扱うメディアデータは、W3C で定められている仕様に従って、短い時間で区切ったデータ構造にセグメント化されている必要があります。MSE では、セグメントを 2 種類に分けて扱います。</p>
<ul>
<li>初期化に必要なヘッダ情報である初期化セグメント</li>
<li>短い時間で区切られたメディアデータ本体が含まれるメディアセグメント</li>
</ul>
<p>MSE は最初に初期化セグメント、その後にメディアセグメントを順番にソース・バッファに渡すと、そのメディアセグメントの順番で再生していきます。</p>
<h3>MSE で簡単な MPEG-DASH プレイヤーを作成してみる</h3>
<p>ここでは <code>XMLHttpRequest</code> と <code>MediaSource</code> API を使用して簡単な MPEG-DASH プレイヤーを作成して、先程 ffmpeg と MP4Box で作った MPEG-DASH コンテンツを再生してみます。</p>
<p>最初に <code>id</code> をつけた <code>video</code> 要素を用意します。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;video id=<span class="string">"video"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>次に <code>XMLHttpRequest</code> で MPD を取得します。MPD は XML ファイルなので、パースして <code>Representation</code> 要素から MIME タイプやコーデックの情報を取得しておきます。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> type, mpd;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"http://localhost:8000/output.mpd"</span>, <span class="literal">true</span>);</div><div class="line">xhr.responseType = <span class="string">"document"</span>;</div><div class="line">xhr.overrideMimeType(<span class="string">"text/xml"</span>);</div><div class="line">xhr.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> mpd = xhr.responseXML;</div><div class="line">  <span class="keyword">const</span> representation = mpd.getElementsByTagName(<span class="string">"Representation"</span>)[<span class="number">0</span>];</div><div class="line">  <span class="keyword">const</span> mimeType = representation.getAttribute(<span class="string">"mimeType"</span>);</div><div class="line">  <span class="keyword">const</span> codecs = representation.getAttribute(<span class="string">"codecs"</span>);</div><div class="line">  type = <span class="string">`<span class="subst">$&#123;mimeType&#125;</span>; codecs="<span class="subst">$&#123;codecs&#125;</span>"`</span></div><div class="line">  mpd = mpd;</div><div class="line">  initializeVideo(); <span class="comment">// 次の関数へ</span></div><div class="line">&#125;;</div><div class="line">xhr.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure></p>
<p>次に <code>MediaSource</code> API で最初に用意した <code>video</code> 要素を拡張し、ソースとしてダウンロードした動画のセグメントを追加できるようにします。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediaSource;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeVideo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  mediaSource = <span class="keyword">new</span> MediaSource();</div><div class="line">  <span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>);</div><div class="line"></div><div class="line">  mediaSource.addEventListener(<span class="string">"sourceopen"</span>, initializeSourceBuffer, <span class="literal">false</span>); <span class="comment">// mediaSource が開いたらソース・バッファを作成する</span></div><div class="line">  video.src = URL.createObjectURL(mediaSource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ソース・バッファを作成し、初期化情報が入ったセグメントとメディア本体のセグメントを追加できるように準備します。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sourceBuffer;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeSourceBuffer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  sourceBuffer = mediaSource.addSourceBuffer(<span class="keyword">this</span>.type);</div><div class="line">  sourceBuffer.addEventListener(<span class="string">"updateend"</span>, appendMediaSegment, <span class="literal">false</span>);</div><div class="line">  appendInitializationSegment(); <span class="comment">// 次の関数へ</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先に取得した <code>mpd</code> から <code>Initialization</code> 要素の <code>sourceURL</code> の値を取得し、 <code>XMLHttpRequest</code> で取得します。セグメントファイルはバイナリデータなので、 <code>responseType</code> を<code>arraybuffer</code> に指定しておきます。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendInitializationSegment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  <span class="keyword">const</span> url = mpd.getElementsByTagName(<span class="string">"Initialization"</span>)[<span class="number">0</span>].getAttribute(<span class="string">"sourceURL"</span>);</div><div class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">`http://localhost:8000/media/<span class="subst">$&#123;url&#125;</span>`</span>, <span class="literal">true</span>);</div><div class="line">  xhr.responseType = <span class="string">"arraybuffer"</span>;</div><div class="line">  xhr.onload = appendSegment;</div><div class="line">  xhr.send(<span class="literal">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>そしてセグメントをロードしたタイミングでソース・バッファに追加します。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendSegment</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  sourceBuffer.appendBuffer(e.target.response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初期化情報がバッファに追加されソースが更新されたら、続けてメディア本体のセグメントファイルを取得し、ソース・バッファに追加します。この処理をメディアセグメントの数だけ繰り返します。</p>
<p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> segmentIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendMediaSegment</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  <span class="keyword">const</span> url = mpd.getElementsByTagName(<span class="string">"SegmentURL"</span>)[segmentIndex++].getAttribute(<span class="string">"media"</span>);</div><div class="line">  xhr.open(<span class="string">"GET"</span>, <span class="string">`http://localhost:8000/media/<span class="subst">$&#123;url&#125;</span>`</span>, <span class="literal">true</span>);</div><div class="line">  xhr.responseType = <span class="string">"arraybuffer"</span>;</div><div class="line">  xhr.onload = appendSegment;</div><div class="line">  xhr.send(<span class="literal">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>メディアセグメント - 動画とは何か</h2>
<p>HLS や MPEG-DASH などのストリーミング配信では、セグメントファイルが実際の動画データになります。本記事の最初に書いた通り、動画データの容量は大きいです。ストリーミング配信の仕組みだけでは、動画の再生開始までの待ち時間は短かくすることはできても、再生を続けるために必要な１秒あたりのデータ量は減らすことはできません。ストリーミング再生では 1 秒あたりに必要なデータ量を少なくとも 1 秒以内に取得し続ける必要があります。でないと再生を継続できません。</p>
<p>同じ情報量を表現するデータの容量を小さくしたい場合、データに圧縮処理をかけます。圧縮のアルゴリズムはいくつもありますが、動画は映像と音声で構成されているため、映像の圧縮に適したアルゴリズムと音声の圧縮に適したアルゴリズムは異なることを考慮する必要があります。映像圧縮に適したアルゴリズムで処理した映像ファイルと音声圧縮に適したアルゴリズムで処理した音声ファイルを１つのファイルとしてまとめたものが動画ファイルです。</p>
<h2>コンテナとコーデック</h2>
<p>動画ファイルは映像ファイルと音声ファイルをまとめたものと説明しましたが、このまとめ方の形式のことをコンテナフォーマットといいます。また、映像データや音声データを圧縮するアルゴリズムのことをコーデックといいます。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/containers-codecs.png" alt="コンテナとコーデック"></p>
<h3>コンテナ</h3>
<p>コンテナフォーマットは一般的にコンテナと略します。コンテナと呼ぶと難しそうですが、コンテナはファイルフォーマットの１種なので、私たちが普段動画ファイルとして意識している単位と一致します。ファイルフォーマットとはファイルの保存形式のことです。以下にリストしたものが代表的なコンテナですが、聞いたことがある名前が多いと思います。</p>
<ul>
<li>AVI</li>
<li>MP4</li>
<li>MOV</li>
<li>MPEG</li>
<li>MKV</li>
<li>WMV</li>
<li>FLV</li>
<li>ASF</li>
</ul>
<p>コンテナは映像と音声データがどのように格納されるのかを定義しています。また動画は映像と音声を同時に再生する必要があるため、両者の同期を取るための情報もコンテナが格納しています。ほかにも動画タイトルや説明などのメタ情報、字幕などの情報もコンテナが格納されている場合があります。</p>
<p>コンテナは対応しているコーデックの映像と音声データのみ格納することができます。１つのコンテナがいくつかのコーデックに対応している場合も多々あるので、コンテナの種類が分かっても格納されているコーデックの種類は分かりません。そのため、動画プレイヤーが同じコンテナで保存された２つの動画ファイルのうち、片方だけ再生できるということもあります。</p>
<p>たとえば Flash 動画のコンテナである FLV は映像コーデックとして「Sorenson Spark」と「H.264/AVC」を格納できます。もし動画プレイヤーが「Sorenson Spark」には対応していても 「H.264/AVC」には対応していなかった場合、「Sorenson Spark」を格納している FLV ファイルは再生できても、「H.264/AVC」を格納している FLV ファイルはコーデックエラーが発生して再生できません。</p>
<h3>コーデック</h3>
<p>映像や音声は圧縮する必要があります。特にストリーミング再生などのデータ通信と再生を同時に行うような場合は必須です。コーデックはその圧縮のアルゴリズムです。</p>
<p>なぜ映像を圧縮する必要があると言うと、映像はたくさんの静止画をパラパラマンガのようにめくって人間の目に物体や背景が動いているように見せているので、このたくさんの静止画は情報量として膨大なのです。</p>
<p>映像を構成する画像データはラスタという色のついたピクセルの集合で表現します。1 ピクセルの情報量は 24 bit で表現できます（24bit フルカラーの場合、R -赤- G -緑- B -青- の各色成分につき 256 段階の指定ができるため、1 ピクセルは <code>Math.log2(256 * 256 * 256) = 24 bit</code> の情報量が必要）。</p>
<p>そうすると例えば、フル HD の 1 フレームを構成する 1920 * 1080 ピクセルの情報量は 49,766,400 (= 24 * 1920 * 1080) bit になります。これはまだ 1 フレームなので、24 fps の動画の場合、1 秒間に 1,194,393,600 (= 49,766,400 * 24) bit が必要になります。</p>
<p>これは 1 秒間に 1,194 Mbit のデータを通信を介して取得する必要があるということになります。しかし、例えば受信実効速度が 76.6Mbps と記載されているソフトバンク提供の超高速データ通信サービス <a href="http://www.softbank.jp/mobile/network/explanation/4glte/" target="_blank" rel="external">SoftBank 4G LTE</a> でデータ通信をした場合でも、 1 秒間に取得できるデータ量は 76.6 Mbit なので、先程の 1,194 Mbit に遠く及びません。</p>
<p>しかし、この 1,194 Mbit の映像データは「H.264/AVC」というコーデックで圧縮した場合、典型的な圧縮率としては 1/100 のデータ量に圧縮することができます。すると 12 Mbit 程度になるので、76.6 Mbps のデータ通信速度でも視聴が可能になります。</p>
<p>この「H.264/AVC」は AbemaTV でも映像コーデックとして使用していますが、映像コーデックにはほかにも以下のような種類があります。</p>
<ul>
<li>H.265</li>
<li>VP8</li>
<li>VP9</li>
<li>MPEG-4</li>
<li>WMV9</li>
</ul>
<p>ここでは映像コーデックしか取り上げませんが、音声コーデックは代表的なものに「AAC」や「MP3」があり、AbemaTV では「AAC」を使用しています。</p>
<p>コーデックはデータ量を圧縮するものですが、ただデータ量を減らせればいいのではなく、人間が知覚できる範囲の画質や音質を落とすことなく圧縮しなくてはいけません。なので、選択するコーデックが悪いと画質や音質を落とすことになります。</p>
<h2>AbemaTV で使用しているコンテナ MPEG-2 TS</h2>
<p>「MPEG-2 TS」は MPEG-2 システムのうち放送・通信用のコンテナです。地上波デジタル放送でも使用されているコンテナですが、HLS でも「MPEG-2 TS」を使用します。DevTools の Network パネルを開いた状態で AbemaTV の動画を視聴しているとたくさんの <code>**.ts</code> という拡張子のデータがリクエストされるのが確認できます。これが「MPEG-2 TS」のファイルです。</p>
<p>「MPEG-2 TS」は放送・通信用に作られたコンテナのため、通信途中でデータが途切れたとしてもちゃんと再生できるように設計されています。「MPEG-2 TS」では動画を 184 バイト単位のデータに分割し、それに 4 バイトの TS ヘッダと呼ばれるデータを付加して計 188 バイト固定長のパケットを連続で転送することでデータ伝送を行います。4 バイトの TS ヘッダのうち最後の 4bit は巡回カウンターと呼ばれるデータを持っていて、これがパケットごとに 1 ずつカウンターするため、これを検査することでパケットの欠落がないかを確認できるようになっています。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/ts-packet.png" alt="TS パケット"></p>
<p>MPEG-2 システムには蓄積メディア用のコンテナとして別に「MPEG-2 PS」がありますが、こちらはデータが連続していることが前提なので、ランダムアクセスなどに優れた設計になっています。</p>
<h2>AbemaTV で使っている映像コーデック H.264/AVC</h2>
<p>AbemaTV では「MPEG-2 TS」コンテナに「H.264/AVC」コーデックで圧縮した映像データを格納しています。「H.264/AVC」は正式名称を「H.264」もしくは「MPEG-4 Part 10 Advanced Video Coding」といいます。（正式名称が２つあるのは ITU-T と ISO/IEC という２つの組織が共同で策定したものをそれぞれの名称をつけているだけです。）「MPEG-4」という名前が付けられている通り、その圧縮アルゴリズムの原理は、従来方式の「MPEG-1」、「MPEG-2」を継承しています。ここでは「MPEG」の圧縮アルゴリズムの原理を学んでいきます。</p>
<h3>圧縮の基本</h3>
<p>データを圧縮する基本は</p>
<ul>
<li>出現するデータパターンに偏りを持たせること</li>
<li>出現頻度が高いパターンを短く表現すること</li>
</ul>
<p>です。単純な例で見ていきます。</p>
<h4>出現頻度が高いパターンを短く表現する</h4>
<p>たとえば、文字 a-d があったとき、それらを識別する符号を下記のように表現できます。</p>
<table>
<thead>
<tr>
<th>文字</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>00</td>
</tr>
<tr>
<td>b</td>
<td>01</td>
</tr>
<tr>
<td>c</td>
<td>10</td>
</tr>
<tr>
<td>d</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>文字列「bbabcbdbaacba」は「01 01 00 01 10 01 11 01 00 00 10 01 00」という符号で表現されます。この文字列を表現するのに必要なデータ量は 26(=2*13)bit です。この文字列にて、各々の文字の出現回数は均一ではありません。</p>
<table>
<thead>
<tr>
<th>文字</th>
<th>出現回数</th>
<th>出現率</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>4</td>
<td>0.31</td>
</tr>
<tr>
<td>b</td>
<td>7</td>
<td>0.54</td>
</tr>
<tr>
<td>c</td>
<td>2</td>
<td>0.15</td>
</tr>
<tr>
<td>d</td>
<td>1</td>
<td>0.08</td>
</tr>
</tbody>
</table>
<p>そこで出現回数が 1 番多い b に 1 番短い符号、2 番目に多い a に次に短い符号を割り当ててみます。</p>
<table>
<thead>
<tr>
<th>文字</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>10</td>
</tr>
<tr>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>c</td>
<td>110</td>
</tr>
<tr>
<td>d</td>
<td>111</td>
</tr>
</tbody>
</table>
<p>すると先程の文字列「bbabcbdbaacba」は「0 0 10 0 110 0 111 0 10 10 110 0 10」と表現されますが、データ量が 23bit に減りました。このように、データの出現頻度が均一ではなく偏りがあると、異なる長さの符号を割り当てることによりデータ量を圧縮することができます。</p>
<p>このように可変長の符号を出現頻度に応じて割り当てることエントロピー符号といいますが、その割り当てパターンを作成する方法の 1 つに<strong>ハフマン符号</strong>があります。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/huffman.png" alt="ハフマン符号"></p>
<p>この図のように出現確立が高いものからツリー上に符号を割り当てていきます。これにて全ての文字が一意かつ瞬時に解読できる少ないデータ量の符号を作成することができます。</p>
<h4>出現するデータパターンに偏りを持たせる</h4>
<p>一見出現率に偏りがない場合でも情報の表現方法を変えることでデータの出現頻度に偏りを持たせることができます。</p>
<p>たとえば、「1 2 3 2 1 0 -1 -2」のような数列はそのままだと下記のような出現回数ですが、</p>
<table>
<thead>
<tr>
<th>数字</th>
<th>出現回数</th>
<th>出現率</th>
</tr>
</thead>
<tbody>
<tr>
<td>-2</td>
<td>1</td>
<td>0.125</td>
</tr>
<tr>
<td>-1</td>
<td>1</td>
<td>0.125</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0.125</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>0.25</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0.25</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0.125</td>
</tr>
</tbody>
</table>
<p>これを前の数字との差分として表現すると「1 2 3 2 1 0 -1 -2」→「0 +1 +1 -1 -1 -1 -1 -1」となり、データの出現頻度に大きな偏りを作ることができました。</p>
<table>
<thead>
<tr>
<th>差分</th>
<th>出現回数</th>
<th>出現率</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0.125</td>
</tr>
<tr>
<td>+1</td>
<td>2</td>
<td>0.25</td>
</tr>
<tr>
<td>-1</td>
<td>5</td>
<td>0.625</td>
</tr>
</tbody>
</table>
<p>これをハフマン符号することでデータを圧縮することができます。</p>
<h3>MPEG の圧縮</h3>
<p>文字列や数列データの圧縮の例について見てきましたが、動画圧縮の場合も基本的な考え方は同様です。しかし、MPEG の場合は動画特有の性質を利用して圧縮率を高める工夫をしています。</p>
<p>MPEG の圧縮アルゴリズムは静止画の圧縮と映像の圧縮で構成されています。</p>
<ul>
<li>静止画自体のデータサイズを圧縮する</li>
<li>連続する映像フレームのデータの差分だけを記録する</li>
</ul>
<h3>静止画の圧縮</h3>
<p>MPEG の静止画の圧縮アルゴリズムの基礎は画像圧縮規格である「JPEG」です。<code>**.jpg</code> の拡張子で馴染のアレです。</p>
<p>静止画の圧縮アルゴリズムは簡単に以下のようなことを行います。</p>
<ul>
<li>画像は隣り合うピクセルが似ているという特徴を利用して差分情報だけで表現する</li>
<li>人間の目が変化に鈍感な情報を省略する</li>
<li>エントロピー符号する</li>
</ul>
<h4>画像は隣り合うピクセルが似ている</h4>
<p>たとえば空の写真を撮影した場合、その画像を構成するピクセルの多くは空の青色と雲の白色の微妙な色味の変化になると思います。空ほど色数が少なくない写真や絵の場合でも、基本的に画像は色が段階的にしか変化していないピクセルの方が出現頻度が圧倒的に多く、急な変化の頻度は少ないはずです。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/xsky_00001.jpg" alt="空"></p>
<p>この画像の性質を利用して、画像データの出現頻度に偏りを作って符号化することを <strong>DPCM 符号化</strong>といいます。</p>
<h4>人間の目が変化に鈍感な情報を省略する</h4>
<p>MPEG は<strong>離散コサイン変換</strong>という演算を行うことで、人間の目にあまり目立たない細かい情報をデータから取り除いてしまうことで圧縮率を上げています。離散コサイン変換は英語では Discrete Cosine Transform というので DCT と略されます。</p>
<p>DCT では画像を波形として扱い、フーリエ変換のように周波数ごとの波の強度で画像を表現します。ここで高い周波数の波は人間の目にあまり目立たない情報となるので、省略してしまうことで画質への影響を最小限に抑えながら圧縮率を高めることが可能になります。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/DCT.png" alt="DCT"></p>
<h4>エントロピー符号</h4>
<p>ここまで静止画の圧縮について、DPCM 符号化と DCT の処理を見てきましたが、これらで求められた値をエントロピー符号することで更に圧縮効率を高めます。</p>
<h3>映像の圧縮</h3>
<p>静止画の圧縮では、映像における 1 枚 1 枚のフレームのデータ量を削減しました。映像の圧縮では、時間の流れを利用してデータの圧縮率を高める工夫をしています。</p>
<h4>画素の省略</h4>
<p>MPEG では画素情報を RGB ではなく、<strong>輝度信号（Y）</strong>、 <strong>色差信号（Cr）（Cb）</strong> で表現します。RGBの各成分、輝度信号（Y）、色差信号（Cr）（Cb）の関係は下記です。</p>
<p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Y = <span class="number">0.299</span>*R + <span class="number">0.587</span>*G + <span class="number">0.114</span>*B</div><div class="line">Cr = <span class="number">0.500</span>*R - <span class="number">0.419</span>*G - <span class="number">0.081</span>*B</div><div class="line">Cb = <span class="number">-0.169</span>*R - <span class="number">0.332</span>*G + <span class="number">0.500</span>*B</div></pre></td></tr></table></figure></p>
<p>人間の目は明るさの変化に対しての方が色の変化に対してより敏感です。MPEG ではその人間の視覚の癖を利用し、フレームごとに Cr と Cb 信号を画素の情報から省いています。Cr と Cb が少々省かれたとしても 明るさの情報である Y が省かれていなければ、人はそれ程違和感を感じないのです。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/y-cr-cb.png" alt="CrCb の省略"></p>
<h4>フレーム間予測</h4>
<p>静止画の場合と似ていますが、映像の場合も時間的に隣合うフレームが持つ画像は似ているはずです。MPEG はその映像の特徴を利用して、映像のフレームにその画像を表示するための全ての情報を持たせません。MPEG には 3 種類のフレームがあります。</p>
<ul>
<li>I ピクチャ</li>
<li>P ピクチャ</li>
<li>B ピクチャ</li>
</ul>
<p><strong>I ピクチャ</strong>を除いて、他のフレームが持ってる情報と自身が持ってる情報を合わせて画像を表示することができるようになります。この 3 種類はそれぞれ役割りが違います。<strong>I ピクチャ</strong>は画像を表示するための全ての情報を持っています。<strong>P ピクチャ</strong>は過去に表示した<strong>I ピクチャ</strong>もしくは<strong>P ピクチャ</strong>が持っていたデータとその差分データを使用して画像を表示します。<strong>B ピクチャ</strong>は過去だけではなく未来の<strong>I ピクチャ</strong>もしくは<strong>P ピクチャ</strong>が持っているデータを利用することでより圧縮率を高めます。</p>
<p><img src="/images/streaming-technology-basics-for-frontend-engineers/ipb-pictures.png" alt="I/P/B ピクチャ"></p>
<h2>まとめ</h2>
<p>動画は昔からある技術分野ですが、Web のフロントエンドエンジニアだった自分には足を踏み込んだら分からないことだらけの難しい分野だと感じました。しかし、最近はストリーミング関連の技術も進み、Web においても動画を扱った事業に関わることが増えてきています。本記事は社内勉強会向けですが、フロントエンドエンジニア視点から動画を学んでいくスタートポイントになればと思います。</p>
<h2>参考</h2>
<p><strong>HTTP Live Streaming</strong></p>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank" rel="external">https://en.wikipedia.org/wiki/HTTP_Live_Streaming</a></p>
<p><strong>H.264</strong></p>
<p><a href="https://ja.wikipedia.org/wiki/H.264" target="_blank" rel="external">https://ja.wikipedia.org/wiki/H.264</a></p>
<p><strong>MPEG-2システム</strong></p>
<p><a href="https://ja.wikipedia.org/wiki/MPEG-2%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0" target="_blank" rel="external">https://ja.wikipedia.org/wiki/MPEG-2%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0</a></p>
<p><strong>HLSとは</strong></p>
<p><a href="http://qiita.com/STomohiko/items/eb223a9cb6325d7d42d9" target="_blank" rel="external">http://qiita.com/STomohiko/items/eb223a9cb6325d7d42d9</a></p>
<p><strong>ffmpeg で mp4 をiPhone用のストリーミング（HLS）に対応させる。</strong></p>
<p><a href="http://takuya-1st.hatenablog.jp/entry/2016/04/06/034906" target="_blank" rel="external">http://takuya-1st.hatenablog.jp/entry/2016/04/06/034906</a></p>
<p><strong>MPEG DASHを知る</strong></p>
<p><a href="http://qiita.com/gabby-gred/items/c1a3dbe026f83dd7e1ff" target="_blank" rel="external">http://qiita.com/gabby-gred/items/c1a3dbe026f83dd7e1ff</a></p>
<p><strong>MPEG-DASH content generation with MP4Box and x264</strong></p>
<p><a href="https://bitmovin.com/mp4box-dash-content-generation-x264/" target="_blank" rel="external">https://bitmovin.com/mp4box-dash-content-generation-x264/</a></p>
<p><strong>Media Source Extensionsを使ってみた (MP4編)</strong>
<a href="http://qiita.com/tomoyukilabs/items/54bd151aba7d3edf8946" target="_blank" rel="external">http://qiita.com/tomoyukilabs/items/54bd151aba7d3edf8946</a></p>
<p><strong>動画・音声の規格について ~コーデック・コンテナ~</strong></p>
<p><a href="http://michisugara.jp/archives/2011/video_and_audio.html" target="_blank" rel="external">http://michisugara.jp/archives/2011/video_and_audio.html</a></p>
<p><strong>VIDEO-ITを取り巻く市場と技術</strong></p>
<p><a href="http://www.mpeg.co.jp/libraries/video_it/index.html" target="_blank" rel="external">http://www.mpeg.co.jp/libraries/video_it/index.html</a></p>
<p><strong>動画形式の種類と違い（AVI･MP4･MOV･MPEG･MKV･WMV･FLV･ASF等）【コンテナ】</strong></p>
<p><a href="http://aviutl.info/dougakeisiki-konntena/" target="_blank" rel="external">http://aviutl.info/dougakeisiki-konntena/</a></p>
<p><strong>【動画が再生できない!?】そんなときに必ず役立つ5つの知識</strong></p>
<p><a href="http://smarvee.com/column/can-not-play/" target="_blank" rel="external">http://smarvee.com/column/can-not-play/</a></p>
<p><strong>「映像がH.264/AVCでエンコードされたFLV」を「FLV5」と呼ぶのは間違い</strong></p>
<p><a href="http://goldenhige.cocolog-nifty.com/blog/2009/10/h264avcflvflv5-.html" target="_blank" rel="external">http://goldenhige.cocolog-nifty.com/blog/2009/10/h264avcflvflv5-.html</a></p>
<p><strong>量子化行列のナゾ～その１</strong></p>
<p><a href="http://www.nnet.ne.jp/~hi6/lab/quantize/" target="_blank" rel="external">http://www.nnet.ne.jp/~hi6/lab/quantize/</a></p>
<p><strong>モニタ解像度 図解チャート＆一覧 / monitor resolution data sheet&amp;chart</strong></p>
<p><a href="http://www.quel.jp/etc/monitor-size/" target="_blank" rel="external">http://www.quel.jp/etc/monitor-size/</a></p>
</div><div class="post__share"><a href="https://twitter.com/share" data-text="フロントエンドエンジニアのための動画ストリーミング技術基礎" data-url="https://ygoto3.com/posts/streaming-technology-basics-for-frontend-engineers/" data-via="ygoto3_" class="twitter-share-button">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
</script><div data-href="https://ygoto3.com/posts/streaming-technology-basics-for-frontend-engineers/" data-layout="button" class="fb-share-button"></div></div></article></div><footer class="pure-u-1"><div class="container-footer"><div class="footer"><div class="pure-g"><div class="pure-u"><img src="/images/ygoto3-avatar.jpg" width="80" height="80" class="footer__avatar"/></div><div class="pure-u-3-4"><a href="/"><h2 class="site-title">ygoto3.com</h2></a><p class="copyright footer__copyright">&copy; 2016&nbsp;Yusuke Goto<a href="https://twitter.com/ygoto3_" class="copyright__icon"><i class="fa fa-lg fa-twitter-square"></i></a><a href="/atom.xml" class="copyright__icon"><i class="fa fa-lg fa-rss-square"></i></a></p></div></div></div></div></footer><script src="/js/app.js"></script></body></html>